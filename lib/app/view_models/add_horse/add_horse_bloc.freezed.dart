// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'add_horse_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddHorseEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() activity,
    required TResult Function() gender,
    required TResult Function() blooded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? activity,
    TResult? Function()? gender,
    TResult? Function()? blooded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? activity,
    TResult Function()? gender,
    TResult Function()? blooded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Activity value) activity,
    required TResult Function(Gender value) gender,
    required TResult Function(Blooded value) blooded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Activity value)? activity,
    TResult? Function(Gender value)? gender,
    TResult? Function(Blooded value)? blooded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Activity value)? activity,
    TResult Function(Gender value)? gender,
    TResult Function(Blooded value)? blooded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddHorseEventCopyWith<$Res> {
  factory $AddHorseEventCopyWith(
          AddHorseEvent value, $Res Function(AddHorseEvent) then) =
      _$AddHorseEventCopyWithImpl<$Res, AddHorseEvent>;
}

/// @nodoc
class _$AddHorseEventCopyWithImpl<$Res, $Val extends AddHorseEvent>
    implements $AddHorseEventCopyWith<$Res> {
  _$AddHorseEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddHorseEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ActivityImplCopyWith<$Res> {
  factory _$$ActivityImplCopyWith(
          _$ActivityImpl value, $Res Function(_$ActivityImpl) then) =
      __$$ActivityImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ActivityImplCopyWithImpl<$Res>
    extends _$AddHorseEventCopyWithImpl<$Res, _$ActivityImpl>
    implements _$$ActivityImplCopyWith<$Res> {
  __$$ActivityImplCopyWithImpl(
      _$ActivityImpl _value, $Res Function(_$ActivityImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddHorseEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ActivityImpl implements Activity {
  const _$ActivityImpl();

  @override
  String toString() {
    return 'AddHorseEvent.activity()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ActivityImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() activity,
    required TResult Function() gender,
    required TResult Function() blooded,
  }) {
    return activity();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? activity,
    TResult? Function()? gender,
    TResult? Function()? blooded,
  }) {
    return activity?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? activity,
    TResult Function()? gender,
    TResult Function()? blooded,
    required TResult orElse(),
  }) {
    if (activity != null) {
      return activity();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Activity value) activity,
    required TResult Function(Gender value) gender,
    required TResult Function(Blooded value) blooded,
  }) {
    return activity(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Activity value)? activity,
    TResult? Function(Gender value)? gender,
    TResult? Function(Blooded value)? blooded,
  }) {
    return activity?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Activity value)? activity,
    TResult Function(Gender value)? gender,
    TResult Function(Blooded value)? blooded,
    required TResult orElse(),
  }) {
    if (activity != null) {
      return activity(this);
    }
    return orElse();
  }
}

abstract class Activity implements AddHorseEvent {
  const factory Activity() = _$ActivityImpl;
}

/// @nodoc
abstract class _$$GenderImplCopyWith<$Res> {
  factory _$$GenderImplCopyWith(
          _$GenderImpl value, $Res Function(_$GenderImpl) then) =
      __$$GenderImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GenderImplCopyWithImpl<$Res>
    extends _$AddHorseEventCopyWithImpl<$Res, _$GenderImpl>
    implements _$$GenderImplCopyWith<$Res> {
  __$$GenderImplCopyWithImpl(
      _$GenderImpl _value, $Res Function(_$GenderImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddHorseEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GenderImpl implements Gender {
  const _$GenderImpl();

  @override
  String toString() {
    return 'AddHorseEvent.gender()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GenderImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() activity,
    required TResult Function() gender,
    required TResult Function() blooded,
  }) {
    return gender();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? activity,
    TResult? Function()? gender,
    TResult? Function()? blooded,
  }) {
    return gender?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? activity,
    TResult Function()? gender,
    TResult Function()? blooded,
    required TResult orElse(),
  }) {
    if (gender != null) {
      return gender();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Activity value) activity,
    required TResult Function(Gender value) gender,
    required TResult Function(Blooded value) blooded,
  }) {
    return gender(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Activity value)? activity,
    TResult? Function(Gender value)? gender,
    TResult? Function(Blooded value)? blooded,
  }) {
    return gender?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Activity value)? activity,
    TResult Function(Gender value)? gender,
    TResult Function(Blooded value)? blooded,
    required TResult orElse(),
  }) {
    if (gender != null) {
      return gender(this);
    }
    return orElse();
  }
}

abstract class Gender implements AddHorseEvent {
  const factory Gender() = _$GenderImpl;
}

/// @nodoc
abstract class _$$BloodedImplCopyWith<$Res> {
  factory _$$BloodedImplCopyWith(
          _$BloodedImpl value, $Res Function(_$BloodedImpl) then) =
      __$$BloodedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BloodedImplCopyWithImpl<$Res>
    extends _$AddHorseEventCopyWithImpl<$Res, _$BloodedImpl>
    implements _$$BloodedImplCopyWith<$Res> {
  __$$BloodedImplCopyWithImpl(
      _$BloodedImpl _value, $Res Function(_$BloodedImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddHorseEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BloodedImpl implements Blooded {
  const _$BloodedImpl();

  @override
  String toString() {
    return 'AddHorseEvent.blooded()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BloodedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() activity,
    required TResult Function() gender,
    required TResult Function() blooded,
  }) {
    return blooded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? activity,
    TResult? Function()? gender,
    TResult? Function()? blooded,
  }) {
    return blooded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? activity,
    TResult Function()? gender,
    TResult Function()? blooded,
    required TResult orElse(),
  }) {
    if (blooded != null) {
      return blooded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Activity value) activity,
    required TResult Function(Gender value) gender,
    required TResult Function(Blooded value) blooded,
  }) {
    return blooded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Activity value)? activity,
    TResult? Function(Gender value)? gender,
    TResult? Function(Blooded value)? blooded,
  }) {
    return blooded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Activity value)? activity,
    TResult Function(Gender value)? gender,
    TResult Function(Blooded value)? blooded,
    required TResult orElse(),
  }) {
    if (blooded != null) {
      return blooded(this);
    }
    return orElse();
  }
}

abstract class Blooded implements AddHorseEvent {
  const factory Blooded() = _$BloodedImpl;
}

/// @nodoc
mixin _$AddHorseState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddHorseStateCopyWith<$Res> {
  factory $AddHorseStateCopyWith(
          AddHorseState value, $Res Function(AddHorseState) then) =
      _$AddHorseStateCopyWithImpl<$Res, AddHorseState>;
}

/// @nodoc
class _$AddHorseStateCopyWithImpl<$Res, $Val extends AddHorseState>
    implements $AddHorseStateCopyWith<$Res> {
  _$AddHorseStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddHorseState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$AddHorseStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddHorseState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'AddHorseState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements AddHorseState {
  const factory _Initial() = _$InitialImpl;
}
